package benchmarking;

import benchmarking.dynamic.NanoDynamicInstance;
import benchmarking.dynamic.NanoDynamicStatic;
import benchmarking.fabric.SumCallback;
import benchmarking.nano.NanoListeners;
import org.openjdk.jmh.annotations.*;
import org.openjdk.jmh.infra.Blackhole;

@Warmup (iterations = 10,
         batchSize = 10_000)
@Fork (1)
@Threads (1)
@State (Scope.Benchmark)
public class Bench {
	@Setup
	public void setup() {
		SumCallback.EVENT.register(i -> i + 1);
		SumCallback.EVENT.register(i -> i + 2);
		SumCallback.EVENT.register(i -> i + 3);
		NanoDynamicInstance.instance = new NanoDynamicInstance();
		NanoDynamicStatic.instance = new NanoDynamicStatic();
	}

	@Benchmark
	public void nanoevents_dynamic_static(Blackhole blackhole) {
		blackhole.consume(NanoDynamicStatic.invoker(0));
	}

	@Benchmark
	public void nanoevents_dynamic_instance(Blackhole blackhole) {
		blackhole.consume(NanoDynamicInstance.invoker(0));
	}

	@Benchmark
	public void nanoevents_static(Blackhole blackhole) {
		blackhole.consume(invoke(0));
	}

	@Benchmark
	public void direct(Blackhole blackhole) {
		int sum = 0;
		sum += 3 + sum;
		sum += 2 + sum;
		sum += 1 + sum;
		blackhole.consume(sum);
	}

	@Benchmark
	public void fabric_callbacks(Blackhole blackhole) {
		blackhole.consume(SumCallback.EVENT.invoker().invoke(0));
	}

	/**
	 * this is the method generated by the transformer, I simply copy pasted it here,
	 * the performance should be identical.
	 *
	 * @see benchmarking.nano.Nano#invoke(int)
	 * @see NanoListeners#one(int)
	 * @see net.devtech.nanoevents.asm.NanoTransformer
	 */
	public static int invoke(int sum) {
		sum += NanoListeners.three(sum);
		sum += NanoListeners.two(sum);
		sum += NanoListeners.one(sum);
		return sum;
	}
}
