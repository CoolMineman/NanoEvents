package benchmarking;

import benchmarking.nano.NanoListeners;
import org.openjdk.jmh.annotations.*;

// shuttle api and microevents needed
@Warmup (iterations = 10,
         batchSize = 10_000)
@Fork (1)
@Threads (1)
@State (Scope.Benchmark)
public class Bench {
	/*private static EventManager eventManager;
	private static ShuttleEventTracker<SumEvent.SumCallbackListener, SumEvent> shuttleEventTracker;

	@Setup
	public void setup() {
		eventManager = new MicroEventManager();
		SumCallback.EVENT.register(i -> i + 1);
		SumCallback.EVENT.register(i -> i + 2);
		SumCallback.EVENT.register(i -> i + 3);

		eventManager.registerEvent(SumEvent.class);
		eventManager.registerListener(SumEvent.class, s -> s.setSum(s.getSum() + s.getSum() + 1), Priority.NORMAL, false);
		eventManager.registerListener(SumEvent.class, s -> s.setSum(s.getSum() + s.getSum() + 2), Priority.NORMAL, false);
		eventManager.registerListener(SumEvent.class, s -> s.setSum(s.getSum() + s.getSum() + 3), Priority.NORMAL, false);

		new EventType<SumCallback>("nano:event") {};

		shuttleEventTracker = ShuttleEventTracker.of(SumEvent.SumCallbackListener.class, SumEvent.class, (e, l) -> {
			for (SumEvent.SumCallbackListener listener : l) {
				e.setSum(e.getSum() + listener.sum(e.getSum()));
			}
		});

		shuttleEventTracker.subscribe(i -> i + 1);
		shuttleEventTracker.subscribe(i -> i + 2);
		shuttleEventTracker.subscribe(i -> i + 3);
	}

	@Benchmark
	public void shuttle(Blackhole blackhole) {
		SumEvent event = new SumEvent(0);
		shuttleEventTracker.postEvent(event);
		blackhole.consume(event.getSum());
	}

	@Benchmark
	public void microEvents(Blackhole blackhole) {
		SumEvent event = new SumEvent(0);
		eventManager.invoke(event);
		blackhole.consume(event.getSum());
	}

	@Benchmark
	public void valo(Blackhole blackhole) {
		int sum = 0;
		for (Object subscriber : EventsImpl.getEventType(new Id("nano:event")).subscribers) {
			sum += ((SumCallback) subscriber).invoke(sum);
		}
		blackhole.consume(sum);
	}

	@Benchmark
	public void invoker(Blackhole blackhole) {
		blackhole.consume(invoke(0));
	}

	@Benchmark
	public void direct(Blackhole blackhole) {
		int sum = 0;
		sum += 3 + sum;
		sum += 2 + sum;
		sum += 1 + sum;
		blackhole.consume(sum);
	}

	@Benchmark
	public void fabric(Blackhole blackhole) {
		blackhole.consume(SumCallback.EVENT.invoker().invoke(0));
	}

	/**
	 * this is the method generated by the transformer, I simply copy pasted it here,
	 * the performance should be identical.
	 *
	 * @see benchmarking.nano.Nano#invoke(int)
	 * @see NanoListeners#one(int)
	 * @see net.devtech.nanoevents.asm.NanoTransformer
	 */
	public static int invoke(int sum) {
		sum += NanoListeners.three(sum);
		sum += NanoListeners.two(sum);
		sum += NanoListeners.one(sum);
		return sum;
	}
}
